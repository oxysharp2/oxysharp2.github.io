<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –∑–º–µ–π–∫–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º —Å–≤–∞–π–ø–∞–º–∏">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêç</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêç</text></svg>">
    <title>–ó–º–µ–π–∫–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            position: fixed;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            width: 100dvw;
            height: 100dvh;
            max-width: 800px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            background: #f0f0f5;
            box-shadow: 0 10px 50px rgba(0,0,0,0.3);
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: #f0f0f5;
            display: block;
            touch-action: none;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.88);
            z-index: 100;
            padding: 5vw;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .screen.active {
            display: flex;
        }

        .menu-title {
            font-size: min(14vw, 56px);
            color: #fff;
            margin-bottom: 2vh;
            text-shadow: 0 3px 15px rgba(0,0,0,0.6);
            font-weight: 700;
        }

        .menu-subtitle {
            font-size: min(4vw, 20px);
            color: #ddd;
            margin-bottom: 4vh;
            font-weight: 400;
        }

        .high-score {
            font-size: min(5vw, 28px);
            color: #ffd700;
            margin-bottom: 4vh;
            font-weight: 600;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: min(4vw, 18px) min(10vw, 50px);
            font-size: min(4.5vw, 22px);
            border-radius: 100px;
            margin: 1.5vh 0;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(0,0,0,0.35);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            min-width: min(60vw, 280px);
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .button:active {
            transform: scale(0.93);
            box-shadow: 0 3px 12px rgba(0,0,0,0.35);
        }

        .button.secondary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .difficulty-btn {
            background: rgba(70, 130, 180, 0.75);
            padding: min(3.5vw, 16px) min(8vw, 40px);
            font-size: min(4vw, 18px);
            min-width: min(70vw, 320px);
        }

        .difficulty-btn.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 0 25px rgba(102, 126, 234, 0.7);
            transform: scale(1.02);
        }

        .settings-title {
            font-size: min(8vw, 40px);
            color: #fff;
            margin-bottom: 3vh;
            font-weight: 700;
        }

        .settings-label {
            font-size: min(5vw, 24px);
            color: #ddd;
            margin-bottom: 3vh;
            font-weight: 500;
        }

        #scoreDisplay {
            position: absolute;
            top: min(2vh, 12px);
            left: min(2vw, 12px);
            background: rgba(0, 0, 0, 0.65);
            color: white;
            padding: min(2vw, 12px) min(5vw, 24px);
            border-radius: 25px;
            font-size: min(5.5vw, 28px);
            font-weight: 700;
            z-index: 50;
            box-shadow: 0 3px 12px rgba(0,0,0,0.4);
        }

        .game-over-panel {
            background: rgba(50, 60, 80, 0.96);
            padding: min(8vw, 40px);
            border-radius: 25px;
            text-align: center;
            max-width: 92%;
        }

        .game-over-title {
            font-size: min(9vw, 44px);
            color: #ff6347;
            margin-bottom: 3vh;
            font-weight: 700;
        }

        .game-over-score {
            font-size: min(6vw, 32px);
            color: #fff;
            margin-bottom: 2vh;
            font-weight: 600;
        }

        .new-record {
            font-size: min(4.5vw, 22px);
            color: #ffd700;
            margin-bottom: 3vh;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .instruction {
            font-size: min(3.5vw, 16px);
            color: #bbb;
            margin-top: 3vh;
            font-weight: 400;
        }

        .pause-text {
            font-size: min(12vw, 56px);
            color: #4facfe;
            margin-bottom: 3vh;
            font-weight: 700;
            text-shadow: 0 0 15px rgba(79, 172, 254, 0.5);
        }

        @media (min-width: 601px) {
            #gameContainer {
                width: min(90vmin, 800px);
                height: min(90vmin, 800px);
            }
        }

        @media (max-width: 600px) {
            #gameContainer {
                max-width: 100vw;
                max-height: 100vh;
                max-width: 100dvw;
                max-height: 100dvh;
            }
        }

        @media (orientation: landscape) and (max-height: 600px) {
            .screen {
                justify-content: flex-start;
                padding-top: 3vh;
            }
            
            .menu-title {
                font-size: min(8vh, 40px);
                margin-bottom: 1vh;
            }
            
            .menu-subtitle {
                font-size: min(3vh, 16px);
                margin-bottom: 2vh;
            }
            
            .high-score {
                font-size: min(4vh, 20px);
                margin-bottom: 2vh;
            }
            
            .button {
                padding: min(2vh, 14px) min(6vw, 40px);
                font-size: min(3.5vh, 18px);
                margin: 1vh 0;
            }
            
            .difficulty-btn {
                padding: min(2vh, 12px) min(5vw, 30px);
                font-size: min(3vh, 16px);
            }
        }

        @media (max-width: 380px) {
            .menu-title {
                font-size: 12vw;
            }
            
            .button {
                font-size: 4vw;
                padding: 3.5vw 9vw;
            }
        }

        @supports (height: 100dvh) {
            body {
                height: 100dvh;
            }
            
            #gameContainer {
                height: 100dvh;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scoreDisplay">0</div>

        <div id="menuScreen" class="screen active">
            <h1 class="menu-title">üêç –ó–ú–ï–ô–ö–ê</h1>
            <p class="menu-subtitle">–ú–æ–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è</p>
            <p id="menuHighScore" class="high-score"></p>
            <button class="button" onclick="startGame()">–ò–≥—Ä–∞—Ç—å</button>
            <button class="button secondary" onclick="showSettings()">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>
            <p class="instruction">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–∞–π–ø–∞–º–∏</p>
        </div>

        <div id="settingsScreen" class="screen">
            <h2 class="settings-title">‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</h2>
            
            <p class="settings-label">–†–∞–∑–º–µ—Ä –ø–æ–ª—è:</p>
            <button class="button difficulty-btn" onclick="selectGridMode(0)" id="grid0">–ö–≤–∞–¥—Ä–∞—Ç–Ω–æ–µ –ø–æ–ª–µ (16x16)</button>
            <button class="button difficulty-btn selected" onclick="selectGridMode(1)" id="grid1">–í—ã—Ç—è–Ω—É—Ç–æ–µ –ø–æ–ª–µ (16x32)</button>
            
            <p class="settings-label" style="margin-top: 4vh;">–°–ª–æ–∂–Ω–æ—Å—Ç—å:</p>
            <button class="button difficulty-btn" onclick="selectDifficulty(0)" id="diff0">–û—á–µ–Ω—å –ª–µ–≥–∫–æ (3 FPS)</button>
            <button class="button difficulty-btn" onclick="selectDifficulty(1)" id="diff1">–õ–µ–≥–∫–æ (5 FPS)</button>
            <button class="button difficulty-btn selected" onclick="selectDifficulty(2)" id="diff2">–°—Ä–µ–¥–Ω–µ (7 FPS)</button>
            <button class="button difficulty-btn" onclick="selectDifficulty(3)" id="diff3">–°–ª–æ–∂–Ω–æ (10 FPS)</button>
            <button class="button difficulty-btn" onclick="selectDifficulty(4)" id="diff4">–•–∞—Ä–¥–∫–æ—Ä (15 FPS)</button>
            <button class="button" onclick="showMenu()" style="margin-top: 3vh;">–ù–∞–∑–∞–¥</button>
        </div>

        <div id="pauseScreen" class="screen">
            <h2 class="pause-text">‚è∏Ô∏è –ü–ê–£–ó–ê</h2>
            <button class="button" onclick="resumeGame()">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button class="button secondary" onclick="showMenu()">–í—ã–π—Ç–∏ –≤ –º–µ–Ω—é</button>
        </div>

        <div id="gameOverScreen" class="screen">
            <div class="game-over-panel">
                <h2 class="game-over-title">üíÄ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h2>
                <p class="game-over-score">–°—á–µ—Ç: <span id="finalScore">0</span></p>
                <p id="newRecordText" class="new-record" style="display: none;">üéâ –ù–û–í–´–ô –†–ï–ö–û–†–î!</p>
                <button class="button" onclick="restartGame()">–†–µ—Å—Ç–∞—Ä—Ç</button>
                <button class="button secondary" onclick="showMenu()">–ú–µ–Ω—é</button>
            </div>
        </div>
    </div>

    <script>
        const GRID_MODES = [
            { name: '–ö–≤–∞–¥—Ä–∞—Ç–Ω–æ–µ –ø–æ–ª–µ (16x16)', width: 16, height: 16 },
            { name: '–í—ã—Ç—è–Ω—É—Ç–æ–µ –ø–æ–ª–µ (16x32)', width: 16, height: 32 }
        ];

        const DIFFICULTIES = [
            { name: '–û—á–µ–Ω—å –ª–µ–≥–∫–æ', fps: 3 },
            { name: '–õ–µ–≥–∫–æ', fps: 5 },
            { name: '–°—Ä–µ–¥–Ω–µ', fps: 7 },
            { name: '–°–ª–æ–∂–Ω–æ', fps: 10 },
            { name: '–•–∞—Ä–¥–∫–æ—Ä', fps: 15 }
        ];

        const COLORS = {
            background: '#f0f0f5',
            grid: '#dcdce6',
            border: '#fafafa',
            head: '#4169E1',
            body: '#6495ED',
            food: '#FF6347',
            text: '#3c465a'
        };

        let canvas, ctx;
        let cellSize;
        let canvasWidth, canvasHeight;
        let gridWidth, gridHeight;
        let dpr = 1;
        let snake = [];
        let direction = { x: 0, y: 1 };
        let nextDirection = { x: 0, y: 1 };
        let food = { x: 0, y: 0 };
        let score = 0;
        let highScore = 0;
        let gameState = 'menu';
        let lastMoveTime = 0;
        let currentDifficulty = 2;
        let currentGridMode = 1;
        let moveDelay;
        let touchStartX = 0;
        let touchStartY = 0;
        let animationId;

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d', { alpha: false });
            
            dpr = window.devicePixelRatio || 1;
            
            const savedGridMode = parseInt(localStorage.getItem('snakeGridMode'));
            if (savedGridMode !== null && savedGridMode >= 0 && savedGridMode < GRID_MODES.length) {
                currentGridMode = savedGridMode;
            }
            
            updateGridSize();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', () => {
                setTimeout(resizeCanvas, 100);
            });
            
            highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
            updateHighScoreDisplay();
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', (e) => e.preventDefault(), { passive: false });
            
            document.addEventListener('keydown', handleKeyboard);
            
            selectDifficulty(currentDifficulty);
            selectGridMode(currentGridMode);
            gameLoop();
        }

        function updateGridSize() {
            const mode = GRID_MODES[currentGridMode];
            gridWidth = mode.width;
            gridHeight = mode.height;
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const rect = container.getBoundingClientRect();
            
            const mode = GRID_MODES[currentGridMode];
            const aspectRatio = mode.width / mode.height;
            
            let width = rect.width;
            let height = rect.height;
            
            if (width / height > aspectRatio) {
                width = height * aspectRatio;
            } else {
                height = width / aspectRatio;
            }
            
            canvasWidth = width;
            canvasHeight = height;
            
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';
            
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            
            ctx.scale(dpr, dpr);
            
            cellSize = canvasWidth / gridWidth;
        }

        function resetGame() {
            snake = [{ x: Math.floor(gridWidth / 2), y: Math.floor(gridHeight / 2) }];
            direction = { x: 0, y: 1 };
            nextDirection = { x: 0, y: 1 };
            score = 0;
            generateFood();
            lastMoveTime = Date.now();
            updateScoreDisplay();
        }

        function generateFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = score;
        }

        function updateHighScoreDisplay() {
            const highScoreElement = document.getElementById('menuHighScore');
            if (highScore > 0) {
                highScoreElement.textContent = `–†–µ–∫–æ—Ä–¥: ${highScore}`;
                highScoreElement.style.display = 'block';
            } else {
                highScoreElement.style.display = 'none';
            }
        }

        function saveHighScore() {
            localStorage.setItem('snakeHighScore', highScore.toString());
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            if (screenId) {
                document.getElementById(screenId).classList.add('active');
            }
        }

        function showMenu() {
            gameState = 'menu';
            showScreen('menuScreen');
            updateHighScoreDisplay();
        }

        function showSettings() {
            showScreen('settingsScreen');
        }

        function startGame() {
            resetGame();
            gameState = 'playing';
            showScreen('');
            document.getElementById('scoreDisplay').style.display = 'block';
        }

        function pauseGame() {
            if (gameState === 'playing') {
                gameState = 'paused';
                showScreen('pauseScreen');
            }
        }

        function resumeGame() {
            if (gameState === 'paused') {
                gameState = 'playing';
                showScreen('');
                lastMoveTime = Date.now();
            }
        }

        function restartGame() {
            resetGame();
            gameState = 'playing';
            showScreen('');
        }

        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = score;
            
            const newRecordText = document.getElementById('newRecordText');
            if (score > highScore) {
                highScore = score;
                saveHighScore();
                newRecordText.style.display = 'block';
            } else {
                newRecordText.style.display = 'none';
            }
            
            showScreen('gameOverScreen');
        }

        function selectDifficulty(index) {
            currentDifficulty = index;
            moveDelay = 1000 / DIFFICULTIES[index].fps;
            
            for (let i = 0; i < DIFFICULTIES.length; i++) {
                const btn = document.getElementById(`diff${i}`);
                if (i === index) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            }
        }

        function selectGridMode(index) {
            currentGridMode = index;
            localStorage.setItem('snakeGridMode', index.toString());
            
            for (let i = 0; i < GRID_MODES.length; i++) {
                const btn = document.getElementById(`grid${i}`);
                if (btn) {
                    if (i === index) {
                        btn.classList.add('selected');
                    } else {
                        btn.classList.remove('selected');
                    }
                }
            }
            
            updateGridSize();
            resizeCanvas();
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!touchStartX || !touchStartY) return;
            if (gameState !== 'playing') return;

            const touch = e.touches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);

            if (absX < 20 && absY < 20) return;

            if (absX > absY) {
                if (deltaX > 0 && direction.x !== -1) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < 0 && direction.x !== 1) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                if (deltaY > 0 && direction.y !== -1) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < 0 && direction.y !== 1) {
                    nextDirection = { x: 0, y: -1 };
                }
            }

            touchStartX = 0;
            touchStartY = 0;
        }

        function handleKeyboard(e) {
            if (gameState !== 'playing') return;

            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y !== 1) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y !== -1) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x !== 1) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x !== -1) nextDirection = { x: 1, y: 0 };
                    break;
                case 'p':
                case 'P':
                    pauseGame();
                    break;
            }
        }

        function update() {
            if (gameState !== 'playing') return;

            const currentTime = Date.now();
            if (currentTime - lastMoveTime < moveDelay) return;

            lastMoveTime = currentTime;
            direction = nextDirection;

            const head = {
                x: (snake[0].x + direction.x + gridWidth) % gridWidth,
                y: (snake[0].y + direction.y + gridHeight) % gridHeight
            };

            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score++;
                updateScoreDisplay();
                generateFood();
            } else {
                snake.pop();
            }
        }

        function draw() {
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (gameState === 'menu') return;

            ctx.strokeStyle = COLORS.grid;
            ctx.lineWidth = 1;
            for (let i = 0; i <= gridWidth; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvasHeight);
                ctx.stroke();
            }
            for (let i = 0; i <= gridHeight; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvasWidth, i * cellSize);
                ctx.stroke();
            }

            ctx.fillStyle = COLORS.food;
            ctx.beginPath();
            ctx.roundRect(
                food.x * cellSize + 2,
                food.y * cellSize + 2,
                cellSize - 4,
                cellSize - 4,
                3
            );
            ctx.fill();
            ctx.strokeStyle = COLORS.border;
            ctx.lineWidth = 1;
            ctx.stroke();

            snake.forEach((segment, index) => {
                if (index === 0) {
                    ctx.fillStyle = COLORS.head;
                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x * cellSize + 2,
                        segment.y * cellSize + 2,
                        cellSize - 4,
                        cellSize - 4,
                        4
                    );
                    ctx.fill();
                    ctx.strokeStyle = COLORS.border;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    const eyeSize = Math.max(2, cellSize / 10);
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(segment.x * cellSize + cellSize * 0.3, segment.y * cellSize + cellSize * 0.35, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * cellSize + cellSize * 0.7, segment.y * cellSize + cellSize * 0.35, eyeSize, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(segment.x * cellSize + cellSize * 0.3, segment.y * cellSize + cellSize * 0.35, eyeSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(segment.x * cellSize + cellSize * 0.7, segment.y * cellSize + cellSize * 0.35, eyeSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = COLORS.body;
                    ctx.beginPath();
                    ctx.roundRect(
                        segment.x * cellSize + 2,
                        segment.y * cellSize + 2,
                        cellSize - 4,
                        cellSize - 4,
                        3
                    );
                    ctx.fill();
                    ctx.strokeStyle = COLORS.border;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
        }

        function gameLoop() {
            update();
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
            };
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(reg => console.log('Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'))
                    .catch(err => console.log('Service Worker –æ—à–∏–±–∫–∞:', err));
            });
        }

        init();
    </script>
</body>
</html>
